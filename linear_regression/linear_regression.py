# -*- coding: utf-8 -*-
"""linear_regression_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yQlE4_fc1ee82CDVtlnjoBc4-5TTnQgH
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

learning_rate = 0.1
training_epochs = 1000

x_train = np.linspace(-1, 1, 100)
y_train = 2*x_train + np.random.randn(*x_train.shape)*0.33

plt.scatter(x_train, y_train)

class LinearModel:
  def __init__(self):
    self.weight = tf.Variable(1.)
    self.bias = tf.Variable(0.)
  def __call__(self, x):
    return self.weight * x + self.bias

def loss(y, predict):
  return tf.reduce_mean(tf.square(y-predict))

def train(linear_model, x, y, learning_rate=0.01):
  with tf.GradientTape() as t:
    current_loss = loss(y, linear_model(x))
  learning_rate_weight, learning_rate_bias = t.gradient(current_loss, [linear_model.weight, linear_model.bias])
  linear_model.weight.assign_sub(learning_rate*learning_rate_weight)
  linear_model.bias.assign_sub(learning_rate*learning_rate_bias)

linear_model = LinearModel()
weights, biases = [], []
epochs = 100
for epoch in range(epochs):
  weights.append(linear_model.weight.numpy())
  biases.append(linear_model.bias.numpy)
  real_loss = loss(y_train, linear_model(x_train))
  train(linear_model, x_train, y_train, learning_rate=learning_rate)
  print(f'Epoch count {epoch}: Loss value: {real_loss.numpy()}' )

plt.scatter(x_train, y_train)
y_pred = linear_model.weight.numpy()*x_train + linear_model.bias.numpy()
plt.plot(x_train, y_pred, 'r')

